module TypeCheckMyC where

-- Haskell module generated by the BNF converter

import AbsMyC
import AbsEvalMyC

import Control.Monad.Error
import Control.Monad.State
import Control.Monad.Identity
import Data.Maybe
import Data.Either
import Data.Map (Map)
import qualified Data.Map as Map

type TypeCheckEnv = Map.Map Id Type

type TypeCheckM a = (ErrorT String (StateT TypeCheckEnv Identity)) a
runTypeCheck :: TypeCheckEnv -> TypeCheckM a -> ((Either String a), TypeCheckEnv)
runTypeCheck env ev = runIdentity (runStateT (runErrorT ev) env)

typeCompare :: Type -> Type -> Bool
typeCompare t1 t2 = t1 == t2

typeCheckIntegerBinOp :: Exp -> Exp -> TypeCheckM (IExp, IExp)
typeCheckIntegerBinOp exp1 exp2 = do
    evExp1 <- transExp exp1
    evExp2 <- transExp exp2
    case (evExp1, evExp2) of
        (Left iExp1, Left iExp2) -> return (iExp1, iExp2)
        _ -> throwError "Error: type error: expected two integer expressions in integer bin op"

typeCheckBooleanBinOp :: Exp -> Exp -> TypeCheckM (BExp, BExp)
typeCheckBooleanBinOp exp1 exp2 = do
    evExp1 <- transExp exp1
    evExp2 <- transExp exp2
    case (evExp1, evExp2) of
        (Right bExp1, Right bExp2) -> return (bExp1, bExp2)
        _ -> throwError "Error: type error: expected two boolean expressions in boolean bin op"

transId :: Id -> TypeCheckM Id
transId x = do
    case x of
        Id string -> return $ Id string
transProgram :: Program -> TypeCheckM EvalProgram
transProgram x = do
    case x of
        Prog [] -> return $ EvProg []
        Prog [h] -> do
            evH <- transStmt h
            return $ EvProg [evH]
        Prog (h:t) -> do
            evH <- transStmt h
            EvProg evT <- transProgram $ Prog t
            return $ EvProg (evH:evT)
transStmtList :: [Stmt] -> TypeCheckM [EvalStmt]
transStmtList stmts = do
    case stmts of
        [] -> return []
        [stmt] -> do
            evStmt <- transStmt stmt
            return [evStmt]
        (h:t) -> do
            evStmt <- transStmt h
            evStmts <- transStmtList t
            return (evStmt:evStmts)
transStmt :: Stmt -> TypeCheckM EvalStmt
transStmt x = do
    case x of
        SVarDef (Decl t i) -> do
            env <- get
            put $ Map.insert i t env
            return $ EvSVarDef (Decl t i)
        SFunDef dec decs stmt -> throwError "transStmt SFunDef not implemented"
        SWhile exp stmt -> do
            evExp <- transExp exp
            case evExp of
                Right bExp -> do
                        evStmt <- transStmt stmt
                        return $ EvSWhile bExp evStmt
                _ -> do
                    throwError "Error: expected boolean expression in while statement"
        SIf exp stmt -> do
            evExp <- transExp exp
            case evExp of
                Right bExp -> do
                    evStmt <- transStmt stmt
                    return $ EvSIf bExp evStmt
                _ -> do
                    throwError "Error: expected boolean expression in if statement"
        SPrint exp -> do
            evExp <- transExp exp
            return $ EvSPrint evExp
        SBlock stmts -> do
            env <- get
            evStmts <- transStmtList stmts
            put env
            return $ EvSBlock evStmts
        SExpStmt exp -> do
            evExp <- transExp exp
            return $ EvSExpStmt evExp
        SAss id exp -> do
            env <- get
            case (Map.lookup id env) of
                Nothing -> throwError ("Error: unbound variable: " ++ (show id))
                Just expectedT -> do
                    evExp <- transExp exp
                    let correctT = either (\_ -> typeCompare Tint expectedT) (\_ -> typeCompare Tbool expectedT) evExp in
                        if correctT then
                            return $ EvSAss id evExp
                        else
                            throwError ("Error: type error in " ++ (show id) ++ " assignment")
        SReturn exp -> throwError "transStmt SReturn not implemented"
transExp :: Exp -> TypeCheckM EvalExp
transExp x = do
    case x of
        EILit integer -> return $ Left $ IEILit integer
        ETrue -> return $ Right $ BETrue
        EFalse -> return $ Right $ BEFalse
        EVar id -> do
            env <- get
            case (Map.lookup id env) of
                Nothing -> throwError ("Error: unbound variable: " ++ (show id))
                Just t -> do
                    case t of
                        Tint -> return $ Left $ IEVar id
                        Tbool -> return $ Right $ BEVar id
                        _ -> throwError ("types other than int/bool not implemented")
        EIncr exp -> do
            evExp <- transExp exp
            case evExp of
                Left iExp -> return $ Left $ IEIncr iExp
                _ -> throwError("Error: type error: expected int experession before '++'")
        EDecr exp -> do
            evExp <- transExp exp
            case evExp of
                Left iExp -> return $ Left $ IEDecr iExp
                _ -> throwError("Error: type error: expected int experession before '--'")
        EMul exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Left $ IEMul iExp1 iExp2
        EDiv exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Left $ IEDiv iExp1 iExp2
        EPlus exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Left $ IEPlus iExp1 iExp2
        EMinus exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Left $ IEMinus iExp1 iExp2
        ELT exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BELT iExp1 iExp2
        ELEq exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BELEq iExp1 iExp2
        EGT exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BEGT iExp1 iExp2
        EGEq exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BEGEq iExp1 iExp2
        EEq exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BEEq iExp1 iExp2
        ENEq exp1 exp2 -> do
            (iExp1, iExp2) <- typeCheckIntegerBinOp exp1 exp2
            return $ Right $ BENEq iExp1 iExp2
        EAnd exp1 exp2 -> do
            (bExp1, bExp2) <- typeCheckBooleanBinOp exp1 exp2
            return $ Right $ BEAnd bExp1 bExp2
        EOr exp1 exp2 -> do
            (bExp1, bExp2) <- typeCheckBooleanBinOp exp1 exp2
            return $ Right $ BEOr bExp1 bExp2
        EApp id exps -> throwError "transExp EApp not implemented"
transType :: Type -> TypeCheckM Type
transType x = do
    case x of
        Tbool -> return Tbool
        Tint -> return Tint
        Tvoid -> return Tvoid
transDec :: Dec -> TypeCheckM Dec
transDec x = do
    case x of
        Decl type_ id -> return $ Decl type_ id
